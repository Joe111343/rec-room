<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>P2P 多人 3D 遊戲（公共 PeerJS）</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  #info {
    position: absolute; top: 10px; left: 10px; color: white;
    font-family: sans-serif; font-size: 14px;
  }
</style>
</head>
<body>
<div id="info">
  <p>WASD 移動，空白鍵上升，方向鍵旋轉，手柄也支援</p>
  <p>輸入對方 ID 連線：</p>
  <input id="peerId" placeholder="對方 ID">
  <button id="connectBtn">連線</button>
  <p>你的 ID：<span id="myId"></span></p>
</div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<!-- PeerJS -->
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>

<script>
// === 建立場景 ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa0d0ff);

const floorGeo = new THREE.PlaneGeometry(100, 100);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x00aa00 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5,10,7);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.3));

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// === 玩家系統 ===
function createPlayer(color){
  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({color});
  const limbGeo = new THREE.BoxGeometry(0.5, 1.5, 0.5);
  const bodyGeo = new THREE.BoxGeometry(1, 2, 0.5);
  const headGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);

  const body = new THREE.Mesh(bodyGeo, mat); body.position.y=1; group.add(body);
  const head = new THREE.Mesh(headGeo, mat); head.position.y=2.2; group.add(head);
  const leftArm = new THREE.Mesh(limbGeo, mat); leftArm.position.set(-0.9,1.2,0); group.add(leftArm);
  const rightArm = new THREE.Mesh(limbGeo, mat); rightArm.position.set(0.9,1.2,0); group.add(rightArm);
  const leftLeg = new THREE.Mesh(limbGeo, mat); leftLeg.position.set(-0.3,-0.3,0); group.add(leftLeg);
  const rightLeg = new THREE.Mesh(limbGeo, mat); rightLeg.position.set(0.3,-0.3,0); group.add(rightLeg);

  return group;
}

const localPlayer = createPlayer(0x0000ff);
scene.add(localPlayer);
const remotePlayers = new Map();

// === 控制 ===
const move = {forward:0, right:0, up:0, rotY:0};
const velocity = 0.1;

document.addEventListener('keydown', e=>{
  if(e.code==="KeyW") move.forward=1;
  if(e.code==="KeyS") move.forward=-1;
  if(e.code==="KeyA") move.right=-1;
  if(e.code==="KeyD") move.right=1;
  if(e.code==="Space") move.up=0.1;
  if(e.code==="ArrowLeft") move.rotY=0.05;
  if(e.code==="ArrowRight") move.rotY=-0.05;
});
document.addEventListener('keyup', e=>{
  if(e.code==="KeyW"||e.code==="KeyS") move.forward=0;
  if(e.code==="KeyA"||e.code==="KeyD") move.right=0;
  if(e.code==="Space") move.up=0;
  if(e.code==="ArrowLeft"||e.code==="ArrowRight") move.rotY=0;
});

// 手柄控制
function handleGamepad(){
  const pads = navigator.getGamepads();
  if(pads[0]){
    const gp = pads[0];
    move.right = gp.axes[0];
    move.forward = -gp.axes[1];
    move.up = gp.buttons[0].pressed ? 0.1 : 0;
    move.rotY = gp.axes[2]*0.05;
  }
}

// === P2P ===
const peer = new Peer(undefined, {
  host: '0.peerjs.com',
  port: 443,
  path: '/',
  secure: true
});

let conn = null;

peer.on('open', id=>{
  document.getElementById('myId').textContent = id;
});

document.getElementById('connectBtn').onclick = ()=>{
  const targetId = document.getElementById('peerId').value;
  if(!targetId) return alert("請輸入對方 ID");
  conn = peer.connect(targetId);
  conn.on('data', onData);
};

peer.on('connection', c=>{
  conn = c;
  conn.on('data', onData);
});

function onData(data){
  if(data.type==='pos'){
    let p = remotePlayers.get(data.id);
    if(!p){
      p = createPlayer(0xff0000);
      scene.add(p);
      remotePlayers.set(data.id, p);
    }
    p.position.copy(data.pos);
    p.rotation.y = data.rot;
  }
}

// 語音聊天
navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
  peer.on('call', call=>{
    call.answer(stream);
    call.on('stream', remoteStream=>{
      const audio = document.createElement('audio');
      audio.srcObject = remoteStream;
      audio.autoplay = true;
      audio.play();
    });
  });

  document.getElementById('connectBtn').addEventListener('click', ()=>{
    const targetId = document.getElementById('peerId').value;
    if(targetId){
      const call = peer.call(targetId, stream);
      call.on('stream', remoteStream=>{
        const audio = document.createElement('audio');
        audio.srcObject = remoteStream;
        audio.autoplay = true;
        audio.play();
      });
    }
  });
});

// === 更新玩家位置 ===
function updatePlayer(){
  localPlayer.rotation.y += move.rotY;
  const dir = new THREE.Vector3(move.right, 0, -move.forward);
  dir.applyAxisAngle(new THREE.Vector3(0,1,0), localPlayer.rotation.y);
  localPlayer.position.addScaledVector(dir, velocity);
  localPlayer.position.y += move.up;
}

// 發送資料
function sendData(){
  if(conn && conn.open){
    conn.send({type:'pos', id:peer.id, pos:localPlayer.position, rot:localPlayer.rotation.y});
  }
}

// === 遊戲迴圈 ===
function animate(){
  requestAnimationFrame(animate);
  handleGamepad();
  updatePlayer();
  sendData();

  // 第三人稱相機跟隨
  const cameraOffset = new THREE.Vector3(0, 3, 6);
  const cameraPos = localPlayer.position.clone().add(cameraOffset.applyAxisAngle(new THREE.Vector3(0,1,0), localPlayer.rotation.y));
  camera.position.lerp(cameraPos, 0.1);
  camera.lookAt(localPlayer.position.clone().add(new THREE.Vector3(0, 1.5, 0)));

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
