<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 物理遊戲範例</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: none;
            background-color: #333;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://unpkg.com/ammo.js@1.0.0/builds/ammo.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // 宣告全域變數
        let scene, camera, renderer;
        let world, rigidBodies = [];
        let clock = new THREE.Clock();

        const GRAVITY = -9.8;
        const TRANSFORM_AUX = new THREE.Object3D();

        let playerMesh, playerBody;
        const keyboardState = {};
        const mouseState = { x: 0, y: 0, isDown: false };
        let mouseLookEnabled = false;

        // 初始化 Three.js 和 Ammo.js
        window.onload = function() {
            // Ammo.js 初始化
            Ammo().then(function(AmmoLib) {
                Ammo = AmmoLib;
                init();
                animate();
            });
        };

        function init() {
            // 建立 Three.js 場景、相機、渲染器
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 2, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 初始化 Ammo.js 物理世界
            let collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
            let dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
            let overlappingPairCache = new Ammo.btDbvtBroadphase();
            let solver = new Ammo.btSequentialImpulseConstraintSolver();
            world = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
            world.setGravity(new Ammo.btVector3(0, GRAVITY, 0));

            // 加入光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // 建立場景物體
            createGround();
            createPlayer();
            createWalls();
            
            // 監聽輸入事件
            setupInputListeners();
        }

        // 建立地面
        function createGround() {
            const groundWidth = 50, groundDepth = 50, groundHeight = 1;
            const groundGeometry = new THREE.BoxGeometry(groundWidth, groundHeight, groundDepth);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.position.y = -groundHeight / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
            
            const groundShape = new Ammo.btBoxShape(new Ammo.btVector3(groundWidth / 2, groundHeight / 2, groundDepth / 2));
            const groundTransform = new Ammo.btTransform();
            groundTransform.setIdentity();
            groundTransform.setOrigin(new Ammo.btVector3(groundMesh.position.x, groundMesh.position.y, groundMesh.position.z));
            const groundMass = 0;
            const localInertia = new Ammo.btVector3(0, 0, 0);
            const motionState = new Ammo.btDefaultMotionState(groundTransform);
            const rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(groundMass, motionState, groundShape, localInertia);
            const groundBody = new Ammo.btRigidBody(rigidBodyInfo);
            world.addRigidBody(groundBody);
        }

        // 建立玩家控制的方塊
        function createPlayer() {
            const playerSize = 2;
            const playerGeometry = new THREE.BoxGeometry(playerSize, playerSize, playerSize);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.position.set(0, 5, 0);
            playerMesh.castShadow = true;
            scene.add(playerMesh);

            const playerShape = new Ammo.btBoxShape(new Ammo.btVector3(playerSize / 2, playerSize / 2, playerSize / 2));
            const playerTransform = new Ammo.btTransform();
            playerTransform.setIdentity();
            playerTransform.setOrigin(new Ammo.btVector3(playerMesh.position.x, playerMesh.position.y, playerMesh.position.z));

            const playerMass = 100;
            const localInertia = new Ammo.btVector3(0, 0, 0);
            playerShape.calculateLocalInertia(playerMass, localInertia);
            const motionState = new Ammo.btDefaultMotionState(playerTransform);
            const rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(playerMass, motionState, playerShape, localInertia);
            playerBody = new Ammo.btRigidBody(rigidBodyInfo);
            playerBody.setAngularFactor(new Ammo.btVector3(0, 0, 0));
            playerBody.setFriction(0.5);

            world.addRigidBody(playerBody);
            rigidBodies.push({ mesh: playerMesh, body: playerBody });
        }
        
        // 建立一道牆壁
        function createWalls() {
            const wallWidth = 20, wallHeight = 5, wallDepth = 2;
            const wallGeometry = new THREE.BoxGeometry(wallWidth, wallHeight, wallDepth);
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
            wallMesh.position.set(0, 2.5, -15);
            wallMesh.castShadow = true;
            scene.add(wallMesh);
            
            const wallShape = new Ammo.btBoxShape(new Ammo.btVector3(wallWidth / 2, wallHeight / 2, wallDepth / 2));
            const wallTransform = new Ammo.btTransform();
            wallTransform.setIdentity();
            wallTransform.setOrigin(new Ammo.btVector3(wallMesh.position.x, wallMesh.position.y, wallMesh.position.z));
            const wallMass = 0; // 靜止不動
            const localInertia = new Ammo.btVector3(0, 0, 0);
            const motionState = new Ammo.btDefaultMotionState(wallTransform);
            const rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(wallMass, motionState, wallShape, localInertia);
            const wallBody = new Ammo.btRigidBody(rigidBodyInfo);
            world.addRigidBody(wallBody);
            rigidBodies.push({ mesh: wallMesh, body: wallBody });
        }
        
        // 設定輸入監聽器
        function setupInputListeners() {
            // 鍵盤輸入
            document.addEventListener('keydown', (event) => keyboardState[event.key.toLowerCase()] = true);
            document.addEventListener('keyup', (event) => keyboardState[event.key.toLowerCase()] = false);

            // 滑鼠控制視角
            renderer.domElement.addEventListener('mousedown', () => {
                mouseState.isDown = true;
                mouseLookEnabled = true;
                renderer.domElement.requestPointerLock(); // 鎖定滑鼠指標
            });
            renderer.domElement.addEventListener('mouseup', () => mouseState.isDown = false);
            document.addEventListener('mousemove', (event) => {
                if (mouseLookEnabled) {
                    mouseState.x += event.movementX * 0.002;
                    mouseState.y += event.movementY * 0.002;
                    mouseState.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseState.y)); // 限制上下視角
                }
            });

            // 處理視窗大小改變
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // 更新玩家輸入
        function updateInput() {
            const moveDirection = new THREE.Vector3();
            const moveSpeed = 100;

            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gamepad = gamepads[0];
            
            if (gamepad) {
                // 手柄左搖桿移動
                const xAxis = gamepad.axes[0];
                const yAxis = gamepad.axes[1];
                if (Math.abs(xAxis) > 0.1) moveDirection.x = xAxis;
                if (Math.abs(yAxis) > 0.1) moveDirection.z = yAxis;

                // 手柄右搖桿控制視角
                const lookX = gamepad.axes[2];
                const lookY = gamepad.axes[3];
                if (Math.abs(lookX) > 0.1) mouseState.x += lookX * 0.02;
                if (Math.abs(lookY) > 0.1) mouseState.y -= lookY * 0.02;
                mouseState.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseState.y));

            } else {
                // 鍵盤移動
                if (keyboardState['w']) moveDirection.z = -1;
                if (keyboardState['s']) moveDirection.z = 1;
                if (keyboardState['a']) moveDirection.x = -1;
                if (keyboardState['d']) moveDirection.x = 1;
            }

            // 應用移動力道
            if (playerBody && (moveDirection.x !== 0 || moveDirection.z !== 0)) {
                moveDirection.normalize().multiplyScalar(moveSpeed);
                const force = new Ammo.btVector3(moveDirection.x, 0, moveDirection.z);
                playerBody.activate(true);
                playerBody.applyCentralForce(force);
            }
        }
        
        // 遊戲主迴圈
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // 更新物理世界
            world.stepSimulation(delta, 10);

            // 更新玩家輸入
            updateInput();

            // 同步 Ammo 物體與 Three.js 物體
            for (let i = 0; i < rigidBodies.length; i++) {
                const objThree = rigidBodies[i].mesh;
                const objAmmo = rigidBodies[i].body;
                
                let motionState = objAmmo.getMotionState();
                if (motionState) {
                    motionState.getWorldTransform(TRANSFORM_AUX);
                    const p = TRANSFORM_AUX.getOrigin();
                    const q = TRANSFORM_AUX.getRotation();
                    objThree.position.set(p.x(), p.y(), p.z());
                    objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
                }
            }

            // 更新相機位置與視角
            if (playerMesh) {
                const playerPos = playerMesh.position;
                const distance = 10;
                const height = 5;

                // 更新相機角度
                camera.rotation.set(mouseState.y, mouseState.x, 0, 'YXZ');
                
                // 追蹤玩家的相機位置
                const cameraOffset = new THREE.Vector3(0, height, distance).applyEuler(camera.rotation);
                camera.position.copy(playerPos).add(cameraOffset);
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
