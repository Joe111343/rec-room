<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D P2P 雙人連線示範（ES Module版）</title>
<style>
  body { margin:0; overflow:hidden; background:#222; }
  #info {
    position: fixed; top: 5px; left: 5px; color:#eee; font-family: monospace; z-index:10;
  }
  #chatLog {
    position: fixed; bottom: 0; left: 0; width: 300px; max-height: 150px; overflow-y: auto;
    background: rgba(0,0,0,0.7); color: #eee; font-size: 13px; padding: 6px; border-radius: 6px;
    z-index: 10;
  }
  #chatInput {
    position: fixed; bottom: 0; left: 0; width: 300px; box-sizing: border-box;
    font-size: 14px; padding: 6px; border-radius: 0 0 6px 6px; border: none;
    outline:none; z-index: 10;
  }
  #npcDialog {
    position: fixed; bottom: 160px; left: 320px; background:rgba(0,0,0,0.8);
    color:#fff; padding: 10px; border-radius: 6px; font-family: monospace; max-width: 300px;
    display:none;
    z-index: 10;
  }
  #peerID {
    position: fixed; top: 5px; right: 5px; color:#eee; font-family: monospace; z-index:10;
    background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 6px;
  }
  #connectSection {
    position: fixed; top: 40px; right: 5px; background: rgba(0,0,0,0.8); padding: 6px; border-radius: 6px; z-index: 10;
    color:#eee; font-family: monospace;
  }
</style>
</head>
<body>

<div id="info">WASD 移動，空白跳躍，Shift 衝刺，Ctrl 蹲下，1/3 切視角，E 跟NPC互動</div>

<div id="peerID">ID: ...</div>

<div id="connectSection">
  <input id="connectInput" placeholder="輸入對方ID連線" style="width:160px;"/>
  <button id="connectBtn">連線</button>
  <div id="connStatus"></div>
</div>

<div id="chatLog"></div>
<input id="chatInput" placeholder="輸入聊天按 Enter 送出" autocomplete="off" />

<div id="npcDialog"></div>

<!-- 這裡是用ES Module方式引入 -->
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/loaders/GLTFLoader.js';
import Peer from 'https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.es.min.js';

let scene, camera, renderer, clock;
let playerMesh, mixer, actions = {};
let remoteMesh;
let velocity = new THREE.Vector3();
let velocityY = 0;
let onGround = false;
let yaw = 0, pitch = 0;
let keys = {};
let sprinting = false, crouching = false;
let cameraMode = 'third';
const playerHeight = 1.8;
const baseSpeed = 4;
const sprintMultiplier = 2;
const gravity = -9.8;
const jumpSpeed = 5;

let npcMesh;

let peer, conn;

init();
animate();

// --- PeerJS setup ---
function setupPeer(){
  peer = new Peer({
    debug: 2,
  });
  peer.on('open', id => {
    document.getElementById('peerID').textContent = 'ID: ' + id;
  });
  peer.on('connection', c => {
    if(conn){
      c.close();
      return;
    }
    conn = c;
    bindConnection();
  });
}
function bindConnection(){
  document.getElementById('connStatus').textContent = '已連線: ' + conn.peer;
  conn.on('data', data => {
    onDataReceived(data);
  });
  conn.on('close', () => {
    document.getElementById('connStatus').textContent = '連線已斷開';
    remoteMesh.visible = false;
  });
}
document.getElementById('connectBtn').onclick = () => {
  if(conn) conn.close();
  const targetID = document.getElementById('connectInput').value.trim();
  if(!targetID) return alert('請輸入對方ID');
  conn = peer.connect(targetID);
  conn.on('open', () => {
    document.getElementById('connStatus').textContent = '已連線: ' + conn.peer;
  });
  conn.on('data', data => onDataReceived(data));
  conn.on('close', () => {
    document.getElementById('connStatus').textContent = '連線已斷開';
    remoteMesh.visible = false;
  });
};

function init(){
  scene = new THREE.Scene();
  clock = new THREE.Clock();

  // 地板
  const floorGeo = new THREE.PlaneGeometry(50, 50);
  const floorMat = new THREE.MeshStandardMaterial({color:0x444444});
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  // 牆壁
  const wallGeo = new THREE.BoxGeometry(50, 5, 1);
  const wallMat = new THREE.MeshStandardMaterial({color:0x666666});
  const wall1 = new THREE.Mesh(wallGeo, wallMat);
  wall1.position.set(0, 2.5, -25);
  wall1.receiveShadow = true;
  wall1.castShadow = true;
  scene.add(wall1);

  const wall2 = wall1.clone();
  wall2.position.set(0, 2.5, 25);
  scene.add(wall2);

  const wall3 = new THREE.Mesh(new THREE.BoxGeometry(1, 5, 50), wallMat);
  wall3.position.set(-25, 2.5, 0);
  scene.add(wall3);

  const wall4 = wall3.clone();
  wall4.position.set(25, 2.5, 0);
  scene.add(wall4);

  // 光源
  const ambientLight = new THREE.AmbientLight(0x666666);
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(10, 20, 10);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  // 攝影機
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  // Renderer
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // 玩家模型載入
  const loader = new GLTFLoader();
  loader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r150/examples/models/gltf/RobotExpressive/RobotExpressive.glb', gltf=>{
    playerMesh = gltf.scene;
    playerMesh.scale.set(0.4,0.4,0.4);
    playerMesh.traverse(c=>{
      if(c.isMesh){
        c.castShadow = true;
        c.receiveShadow = true;
      }
    });
    scene.add(playerMesh);

    mixer = new THREE.AnimationMixer(playerMesh);
    gltf.animations.forEach(anim=>{
      actions[anim.name] = mixer.clipAction(anim);
    });

    actions['Idle'].play();
  });

  // 遠端玩家 (簡化為藍色盒子)
  remoteMesh = new THREE.Group();
  const remoteGeo = new THREE.BoxGeometry(1, 2, 1);
  const remoteMat = new THREE.MeshStandardMaterial({color:0x8888ff, transparent:true, opacity:0.7});
  const remoteBox = new THREE.Mesh(remoteGeo, remoteMat);
  remoteBox.castShadow = true;
  remoteMesh.add(remoteBox);
  remoteMesh.position.set(0,1,0);
  scene.add(remoteMesh);
  remoteMesh.visible = false;

  // NPC
  const npcGeo = new THREE.BoxGeometry(1, 2, 1);
  const npcMat = new THREE.MeshStandardMaterial({color:0x00aa00});
  npcMesh = new THREE.Mesh(npcGeo, npcMat);
  npcMesh.position.set(5,1,0);
  npcMesh.castShadow = true;
  scene.add(npcMesh);

  // 事件
  window.addEventListener('resize', onWindowResize);
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);
  document.getElementById('chatInput').addEventListener('keydown', onChatKeyDown);

  // 鎖定滑鼠並控制視角
  document.body.addEventListener('click', () => {
    if (document.pointerLockElement !== renderer.domElement) {
      renderer.domElement.requestPointerLock();
    }
  });

  document.addEventListener('pointerlockchange', () => {
    if (document.pointerLockElement === renderer.domElement) {
      document.addEventListener('mousemove', onMouseMove);
    } else {
      document.removeEventListener('mousemove', onMouseMove);
    }
  });

  setupPeer();
}

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onKeyDown(e){
  if(document.activeElement===document.getElementById('chatInput')) return;
  keys[e.code] = true;

  if(e.code==='Digit1') cameraMode = 'first';
  if(e.code==='Digit3') cameraMode = 'third';

  if(e.code==='ShiftLeft' || e.code==='ShiftRight') sprinting = true;
  if(e.code==='ControlLeft' || e.code==='ControlRight') crouching = true;

  if(e.code==='KeyE'){
    if(playerMesh && npcMesh){
      const dist = playerMesh.position.distanceTo(npcMesh.position);
      if(dist < 2.5){
        showNpcDialog("NPC：哈囉！這是個示範對話框。\n你可以用E鍵與NPC互動。");
      }
    }
  }
}

function onKeyUp(e){
  keys[e.code] = false;
  if(e.code==='ShiftLeft' || e.code==='ShiftRight') sprinting = false;
  if(e.code==='ControlLeft' || e.code==='ControlRight') crouching = false;
}

function onMouseMove(e){
  const sensitivity = 0.002;
  yaw -= e.movementX * sensitivity;
  pitch -= e.movementY * sensitivity;
  pitch = Math.min(Math.max(pitch, -Math.PI/2 + 0.1), Math.PI/2 - 0.1);
}

function onChatKeyDown(e){
  if(e.key==='Enter'){
    const input = e.target;
    const text = input.value.trim();
    if(text.length>0 && conn && conn.open){
      conn.send({type:'chat', text});
      addChat('我', text);
      input.value = '';
    }
  }
}

function addChat(name, msg){
  const chatLog = document.getElementById('chatLog');
  const div = document.createElement('div');
  div.textContent = name + ": " + msg;
  chatLog.appendChild(div);
  chatLog.scrollTop = chatLog.scrollHeight;
}

function showNpcDialog(text){
  const dlg = document.getElementById('npcDialog');
  dlg.textContent = text;
  dlg.style.display = 'block';
  setTimeout(()=>{
    dlg.style.display = 'none';
  }, 5000);
}

function onDataReceived(data){
  if(data.type === 'posRot'){
    if(remoteMesh){
      remoteMesh.visible = true;
      remoteMesh.position.set(data.pos.x, data.pos.y, data.pos.z);
      remoteMesh.rotation.y = data.rotY;
    }
  } else if(data.type === 'chat'){
    addChat('對方', data.text);
  }
}

function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  if(mixer) mixer.update(dt);

  if(playerMesh){
    // 移動邏輯
    let dir = new THREE.Vector3();
    if(keys['KeyW']) dir.z -= 1;
    if(keys['KeyS']) dir.z += 1;
    if(keys['KeyA']) dir.x -= 1;
    if(keys['KeyD']) dir.x += 1;
    dir.normalize();

    let speed = baseSpeed * (sprinting ? sprintMultiplier : 1);

    // 用yaw和pitch算方向向量
    const forward = new THREE.Vector3(
      -Math.sin(yaw) * Math.cos(pitch),
      0,
      -Math.cos(yaw) * Math.cos(pitch)
    ).normalize();
    const right = new THREE.Vector3(
      Math.sin(yaw - Math.PI/2),
      0,
      Math.cos(yaw - Math.PI/2)
    ).normalize();

    let moveDir = new THREE.Vector3();
    moveDir.addScaledVector(forward, dir.z);
    moveDir.addScaledVector(right, dir.x);
    moveDir.normalize();

    velocity.x = moveDir.x * speed;
    velocity.z = moveDir.z * speed;

    // 跳躍與重力
    velocityY += gravity * dt;
    if(onGround && keys['Space']){
      velocityY = jumpSpeed;
      onGround = false;
    }

    playerMesh.position.x += velocity.x * dt;
    playerMesh.position.y += velocityY * dt;
    playerMesh.position.z += velocity.z * dt;

    playerMesh.scale.y = crouching ? 0.5 : 1;

    if(playerMesh.position.y <= playerHeight/2 * playerMesh.scale.y){
      playerMesh.position.y = playerHeight/2 * playerMesh.scale.y;
      velocityY = 0;
      onGround = true;
    }

    playerMesh.rotation.y = yaw;

    if(mixer){
      if(dir.length() > 0){
        if(!actions['Walking']?.isRunning()){
          actions['Idle']?.stop();
          actions['Walking']?.play();
        }
      } else {
        if(!actions['Idle']?.isRunning()){
          actions['Walking']?.stop();
          actions['Idle']?.play();
        }
      }
    }

    // 傳送玩家位置給對方
    if(conn && conn.open){
      conn.send({
        type: 'posRot',
        pos: playerMesh.position,
        rotY: yaw,
      });
    }
  }

  if(playerMesh){
    if(cameraMode==='first'){
      const camHeight = playerHeight * (crouching ? 0.5 : 1) - 0.1;
      camera.position.set(playerMesh.position.x, playerMesh.position.y + camHeight, playerMesh.position.z);
      const lookDir = new THREE.Vector3(
        Math.sin(yaw) * Math.cos(pitch),
        Math.sin(pitch),
        Math.cos(yaw) * Math.cos(pitch)
      );
      camera.lookAt(camera.position.clone().add(lookDir));
    } else {
      const offsetBack = 4;
      const offsetUp = 2;
      camera.position.set(
        playerMesh.position.x - Math.sin(yaw) * offsetBack,
        playerMesh.position.y + offsetUp,
        playerMesh.position.z - Math.cos(yaw) * offsetBack
      );
      const lookTarget = playerMesh.position.clone();
      lookTarget.y += playerHeight * (crouching ? 0.5 : 1) * 0.8;
      camera.lookAt(lookTarget);
    }
  }

  renderer.render(scene, camera);
}
</script>

</body>
</html>
