    mesh.position.set(x,y,z);
    scene.add(mesh);
    // 牆體碰撞盒
    const box = new THREE.Box3().setFromObject(mesh);
    walls.push(box);
  }

  // 建四面牆（可調大小）
  createWall(0,2.5,-25, 50,5,1);
  createWall(0,2.5,25, 50,5,1);
  createWall(-25,2.5,0, 1,5,50);
  createWall(25,2.5,0, 1,5,50);

  // 玩家設定
  const player = {
    pos: new THREE.Vector3(0,0.85,0),
    vel: new THREE.Vector3(0,0,0),
    yaw: 0,
    pitch: 0,
    grounded: false,
  };

  const playerHeight = 1.7;
  const playerWidth = 0.6;

  // 鍵盤狀態監聽
  const keys = {};
  window.addEventListener('keydown', e=>{
    keys[e.code] = true;
    if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)){
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', e=>{
    keys[e.code] = false;
  });

  // 滑鼠視角
  function onMouseMove(e){
    player.yaw -= e.movementX * 0.002;
    player.pitch -= e.movementY * 0.002;
    const limit = Math.PI/2 - 0.1;
    if(player.pitch > limit) player.pitch = limit;
    if(player.pitch < -limit) player.pitch = -limit;
  }

  document.body.addEventListener('click', ()=>{
    if(document.pointerLockElement !== document.body){
      document.body.requestPointerLock();
      // 取得麥克風權限（連線後才用會好些，但這邊先示範）
      navigator.mediaDevices.getUserMedia({audio:true})
        .then(stream => {
          localStream = stream;
          log('已取得麥克風權限');
        }).catch(e => {
          log('麥克風權限拒絕或錯誤');
        });
    }
  });

  document.addEventListener('pointerlockchange', ()=>{
    if(document.pointerLockElement === document.body){
      document.addEventListener('mousemove', onMouseMove);
    } else {
      document.removeEventListener('mousemove', onMouseMove);
    }
  });

  // 玩家碰撞盒
  function getPlayerBox(pos){
    return new THREE.Box3(
      new THREE.Vector3(pos.x - playerWidth/2, pos.y - playerHeight, pos.z - playerWidth/2),
      new THREE.Vector3(pos.x + playerWidth/2, pos.y, pos.z + playerWidth/2),
    );
  }

  // 碰撞檢查
  function checkCollision(pos){
    const box = getPlayerBox(pos);
    for(let wall of walls){
      if(box.intersectsBox(wall)){
        return true;
      }
    }
    return false;
  }

  // 嘗試移動
  function tryMove(dx, dy, dz){
    const newPos = player.pos.clone().add(new THREE.Vector3(dx, dy, dz));
    if(!checkCollision(newPos)){
      player.pos.copy(newPos);
      return true;
    }
    return false;
  }

  // 物理參數
  const moveSpeed = 5;
  const jumpVelocity = 6;
  const gravity = -9.8;

  function tryJump(){
    if(player.grounded){
      player.vel.y = jumpVelocity;
      player.grounded = false;
    }
  }

  // 主迴圈
  let lastTime = performance.now();
  function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const delta = (now - lastTime)/1000;
    lastTime = now;

    // 移動輸入
    let moveX = 0, moveZ = 0;
    if(keys['KeyW']) moveZ -= 1;
    if(keys['KeyS']) moveZ += 1;
    if(keys['KeyA']) moveX -= 1;
    if(keys['KeyD']) moveX += 1;

    if(moveX !== 0 || moveZ !== 0){
      const dir = new THREE.Vector3(moveX,0,moveZ).normalize();
      const forward = new THREE.Vector3(Math.sin(player.yaw), 0, -Math.cos(player.yaw));
      const right = new THREE.Vector3(Math.sin(player.yaw + Math.PI/2), 0, -Math.cos(player.yaw + Math.PI/2));
      const worldMove = new THREE.Vector3();
      worldMove.addScaledVector(forward, dir.z);
      worldMove.addScaledVector(right, dir.x);
      worldMove.multiplyScalar(moveSpeed * delta);

      tryMove(worldMove.x, 0, worldMove.z);
    }

    if(keys['Space']){
      tryJump();
    }

    // 重力計算與碰撞地面
    player.vel.y += gravity * delta;
    const newY = player.pos.y + player.vel.y * delta;

    if(newY < 0.85){
      player.vel.y = 0;
      player.pos.y = 0.85;
      player.grounded = true;
    } else {
      const testPos = player.pos.clone();
      testPos.y = newY;
      if(!checkCollision(testPos)){
        player.pos.y = newY;
      } else {
        player.vel.y = 0;
      }
      player.grounded = false;
    }

    // 設定相機位置與旋轉
    camera.position.copy(player.pos).add(new THREE.Vector3(0,0.6,0));
    camera.rotation.order = 'YXZ';
    camera.rotation.y = player.yaw;
    camera.rotation.x = player.pitch;

    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
