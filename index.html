<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>第一人稱無限跳躍＋物品撿取示範</title>
<style>
  body { margin: 0; overflow: hidden; background: #222; color:#eee; font-family: monospace;}
  #inventory {
    position: fixed; top: 10px; right: 10px; width: 320px; max-height: 400px;
    background: rgba(0,0,0,0.7); border: 1px solid #666; padding: 10px; overflow-y: auto;
  }
  #inventory h2 { margin: 0 0 10px 0; font-weight: normal; font-size: 18px; }
  #inventory ul { list-style:none; padding:0; margin:0; }
  #inventory li {
    padding: 3px 5px; border-bottom: 1px solid #444; display: flex; align-items: center;
  }
  #inventory li img {
    width: 24px; height: 24px; margin-right: 8px;
    object-fit: contain;
    border-radius: 3px;
  }
  #info {
    position: fixed; bottom: 10px; left: 10px; font-size: 14px;
    background: rgba(0,0,0,0.7); padding: 8px; border-radius: 4px; user-select: none;
  }
</style>
</head>
<body>
<div id="inventory">
  <h2>背包</h2>
  <ul id="inv-list"><li>載入物品中...</li></ul>
</div>
<div id="info">WASD移動，滑鼠看視角，空白跳，E或手柄X撿起物品</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>

<script>
  let itemsDB = {};
  const inventory = [];
  const pickupDistance = 2.0;

  // three.js 初始化
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x444444);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.7, 5);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // 地板
  const floorGeo = new THREE.PlaneGeometry(50,50);
  const floorMat = new THREE.MeshStandardMaterial({color:0x777777});
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  // 燈光
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
  dirLight.position.set(5,10,7);
  scene.add(dirLight);

  // 玩家物件
  const player = {
    pos: new THREE.Vector3(0, 1.7, 5),
    vel: new THREE.Vector3(0, 0, 0),
    yaw: 0,
    pitch: 0
  };

  const gravity = -9.8;
  const moveSpeed = 6;
  const jumpVelocity = 6;
  const pitchLimit = Math.PI/2 - 0.1;

  // 控制狀態
  const keys = {w:false, a:false, s:false, d:false, space:false, e:false};

  window.addEventListener('keydown', e => {
    if(e.code === 'KeyW') keys.w = true;
    else if(e.code === 'KeyA') keys.a = true;
    else if(e.code === 'KeyS') keys.s = true;
    else if(e.code === 'KeyD') keys.d = true;
    else if(e.code === 'Space') keys.space = true;
    else if(e.code === 'KeyE') keys.e = true;
  });
  window.addEventListener('keyup', e => {
    if(e.code === 'KeyW') keys.w = false;
    else if(e.code === 'KeyA') keys.a = false;
    else if(e.code === 'KeyS') keys.s = false;
    else if(e.code === 'KeyD') keys.d = false;
    else if(e.code === 'Space') keys.space = false;
    else if(e.code === 'KeyE') keys.e = false;
  });

  // 滑鼠視角 (Pointer Lock)
  function onMouseMove(e){
    player.yaw -= e.movementX * 0.002;
    player.pitch -= e.movementY * 0.002;
    player.pitch = Math.min(pitchLimit, Math.max(-pitchLimit, player.pitch));
  }
  document.body.addEventListener('click', ()=>document.body.requestPointerLock());
  document.addEventListener('pointerlockchange', ()=>{
    if(document.pointerLockElement === document.body){
      document.addEventListener('mousemove', onMouseMove);
    } else {
      document.removeEventListener('mousemove', onMouseMove);
    }
  });

  // 手柄支援
  let gamepadIndex = null;
  window.addEventListener('gamepadconnected', e => {
    gamepadIndex = e.gamepad.index;
    console.log('Gamepad connected:', e.gamepad.id);
  });
  window.addEventListener('gamepaddisconnected', e => {
    if(gamepadIndex === e.gamepad.index) gamepadIndex = null;
    console.log('Gamepad disconnected');
  });

  // 場景物品類
  class PickupItem {
    constructor(key, pos){
      this.key = key;
      this.pos = pos.clone();

      const geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
      const mat = new THREE.MeshStandardMaterial({color: 0xffaa00});
      this.mesh = new THREE.Mesh(geo, mat);
      this.mesh.position.copy(this.pos);
      scene.add(this.mesh);

      this.picked = false;
    }
  }

  const itemsInWorld = [];

  function spawnItem(key, pos){
    const item = new PickupItem(key, pos);
    itemsInWorld.push(item);
  }

  // 背包 UI 更新
  function updateInventoryUI(){
    const invList = document.getElementById('inv-list');
    invList.innerHTML = '';
    if(inventory.length === 0){
      invList.innerHTML = '<li>空空如也</li>';
      return;
    }
    inventory.forEach(key=>{
      const item = itemsDB[key];
      if(!item) return;
      const li = document.createElement('li');
      if(item.img){
        const img = document.createElement('img');
        img.src = item.img;
        img.alt = item.name;
        li.appendChild(img);
      }
      li.appendChild(document.createTextNode(`${item.name} - ${item.desc}`));
      invList.appendChild(li);
    });
  }

  // 嘗試撿起物品
  function tryPickup(){
    for(let item of itemsInWorld){
      if(item.picked) continue;
      const dist = player.pos.distanceTo(item.pos);
      if(dist <= pickupDistance){
        inventory.push(item.key);
        item.picked = true;
        scene.remove(item.mesh);
        updateInventoryUI();
        break;
      }
    }
  }

  // 碰撞地面簡易實作
  function collideWithGround(){
    const groundHeight = 0;
    const eyeHeight = 1.7;
    if(player.pos.y < groundHeight + eyeHeight){
      player.pos.y = groundHeight + eyeHeight;
      player.vel.y = 0;
    }
  }

  let lastTime = performance.now();

  function tryJump(){
    player.vel.y = jumpVelocity;
  }

  // 讀取物品 JSON，成功後放置幾個物品在場景
  fetch('1.json')
  .then(res => res.json())
  .then(data => {
    itemsDB = data;
    updateInventoryUI();

    // 放物品示範
    spawnItem('apple', new THREE.Vector3(2,1,2));
    spawnItem('key', new THREE.Vector3(-2,1,3));
    spawnItem('sword', new THREE.Vector3(0,1,-3));
    spawnItem('shield', new THREE.Vector3(-3,1,-2));
    spawnItem('potion', new THREE.Vector3(4,1,-1));
  })
  .catch(err => {
    console.error('讀取 1.json 失敗:', err);
  });

  // 遊戲主迴圈
  function animate(){
    requestAnimationFrame(animate);

    let now = performance.now();
    let delta = (now - lastTime)/1000;
    lastTime = now;

    // 手柄控制
    if(gamepadIndex !== null){
      const gp = navigator.getGamepads()[gamepadIndex];
      if(gp){
        const lx = Math.abs(gp.axes[0]) > 0.15 ? gp.axes[0] : 0;
        const ly = Math.abs(gp.axes[1]) > 0.15 ? gp.axes[1] : 0;
        const rx = Math.abs(gp.axes[2]) > 0.15 ? gp.axes[2] : 0;
        const ry = Math.abs(gp.axes[3]) > 0.15 ? gp.axes[3] : 0;

        player.yaw -= rx * 2 * delta;
        player.pitch -= ry * 2 * delta;
        player.pitch = Math.min(pitchLimit, Math.max(-pitchLimit, player.pitch));

        let forward = new THREE.Vector3(Math.sin(player.yaw),0,Math.cos(player.yaw));
        let right = new THREE.Vector3(Math.sin(player.yaw - Math.PI/2),0,Math.cos(player.yaw - Math.PI/2));

        let moveDir = new THREE.Vector3();
        moveDir.addScaledVector(forward, -ly);
        moveDir.addScaledVector(right, lx);

        if(moveDir.length() > 0){
          moveDir.normalize();
          player.pos.x += moveDir.x * moveSpeed * delta;
          player.pos.z += moveDir.z * moveSpeed * delta;
        }

        if(gp.buttons[2].pressed) tryPickup();
        if(gp.buttons[0].pressed) tryJump();
      }
    }

    // 鍵盤控制
    let dirX = 0, dirZ = 0;
    if(keys.w) dirZ -= 1;
    if(keys.s) dirZ += 1;
    if(keys.a) dirX -= 1;
    if(keys.d) dirX += 1;

    let moveVec = new THREE.Vector3(dirX,0,dirZ);
    if(moveVec.length() > 0){
      moveVec.normalize();
      let forward = new THREE.Vector3(Math.sin(player.yaw),0,Math.cos(player.yaw));
      let right = new THREE.Vector3(Math.sin(player.yaw - Math.PI/2),0,Math.cos(player.yaw - Math.PI/2));
      let moveDir = new THREE.Vector3();
      moveDir.addScaledVector(forward, moveVec.z);
      moveDir.addScaledVector(right, moveVec.x);
      player.pos.x += moveDir.x * moveSpeed * delta;
      player.pos.z += moveDir.z * moveSpeed * delta;
    }

    if(keys.space) tryJump();
    if(keys.e) tryPickup();

    // 重力
    player.vel.y += gravity * delta;
    player.pos.y += player.vel.y * delta;

    collideWithGround();

    // 相機位置和方向更新
    camera.position.copy(player.pos);
    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');

    renderer.render(scene, camera);
  }

  animate();

  // 視窗大小調整
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
