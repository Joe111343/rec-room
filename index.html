<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>P2P 雙人房主/連線 ID 輸入示範</title>
<style>
  body { margin:0; overflow:hidden; background:#222; color:#eee; font-family: monospace; }
  #ui {
    position: fixed; top: 10px; left: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px; border-radius: 5px; max-width: 320px;
    z-index: 10;
  }
  #log {
    max-height: 100px; overflow-y: auto; margin-top: 10px; font-size: 12px;
    background: #111; padding: 5px; border-radius: 3px;
  }
  input[type=text] {
    font-size: 14px; padding: 4px; width: 100px;
    border-radius: 3px; border: none; outline:none;
  }
  button {
    font-size: 14px; padding: 4px 10px; border-radius: 3px;
    border:none; cursor:pointer; margin-left: 8px;
  }
</style>
</head>
<body>

<div id="ui">
  <div>你的ID（5位數）：<span id="myId">...</span></div>
  <div>
    連線到ID：<input type="text" id="inputId" maxlength="5" placeholder="輸入5位ID" />
    <button id="btnConnect">連線</button>
  </div>
  <div id="status">連線狀態：尚未連線</div>
  <div id="log"></div>
  <div style="margin-top:8px; font-size:14px;">
    WASD移動，滑鼠看視角，空白跳<br>
    點擊畫面啟用滑鼠控制與麥克風<br>
    先開一個頁面成為房主，另一個輸入ID連線
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

<script>
  const logElem = document.getElementById('log');
  const myIdSpan = document.getElementById('myId');
  const statusDiv = document.getElementById('status');
  const inputId = document.getElementById('inputId');
  const btnConnect = document.getElementById('btnConnect');

  function log(text){
    logElem.textContent += text + '\n';
    logElem.scrollTop = logElem.scrollHeight;
  }
  function setStatus(text){
    statusDiv.textContent = '連線狀態：' + text;
  }

  // 產生 5 位數 ID (字串)
  function gen5DigitId(){
    return Math.floor(10000 + Math.random()*90000).toString();
  }

  let peer = null;
  let myId = null;
  let conn = null;
  let call = null;
  let localStream = null;

  let isHost = false;

  function setupPeer(id){
    peer = new Peer(id);

    peer.on('open', id => {
      myId = id;
      myIdSpan.textContent = id;
      log('Peer 開啟，ID: ' + id);
      setStatus('等待連線或輸入對方ID連線');

      // 如果是房主，監聽連線與來電
      if(isHost){
        peer.on('connection', c => {
          if(conn){
            c.close();
            log('已有連線，拒絕新連線');
            return;
          }
          conn = c;
          setupDataConn();
          setStatus('房主已連線');
          log('房主接收到連線');
        });

        peer.on('call', incomingCall => {
          navigator.mediaDevices.getUserMedia({audio:true})
          .then(stream => {
            localStream = stream;
            incomingCall.answer(stream);
            setupCall(incomingCall);
          })
          .catch(e => {
            log('取得麥克風失敗：' + e);
            setStatus('取得麥克風失敗');
          });
        });
      }
    });

    peer.on('error', e => log('Peer 錯誤: ' + e));
  }

  function setupDataConn(){
    conn.on('data', onDataReceived);
    conn.on('close', () => {
      setStatus('連線已斷開');
      log('DataChannel關閉');
      conn = null;
      call = null;
    });
    conn.on('error', e => log('DataChannel錯誤：' + e));
  }

  function setupCall(c){
    call = c;
    call.on('stream', remoteStream => {
      const audio = new Audio();
      audio.srcObject = remoteStream;
      audio.play();
      log('開始播放遠端語音');
    });
    call.on('close', () => {
      setStatus('語音通話結束');
      log('語音通話結束');
      call = null;
    });
  }

  // 按鈕事件，開始當房主或連線
  btnConnect.onclick = () => {
    if(conn){
      log('已連線，請刷新頁面重試');
      return;
    }

    const targetId = inputId.value.trim();
    if(!/^\d{5}$/.test(targetId)){
      alert('請輸入5位數數字ID');
      return;
    }

    // 如果輸入ID等於自己ID，自己是房主
    if(targetId === myId){
      alert('不能連線自己ID，這是你的ID');
      return;
    }

    if(!myId){
      alert('尚未取得本機ID，請稍候');
      return;
    }

    log('嘗試連線到 ID: ' + targetId);

    // 當客戶端，連線到目標ID
    conn = peer.connect(targetId);

    conn.on('open', () => {
      setStatus('已連線至 ' + targetId);
      log('連線成功');
      // 啟用麥克風，開始語音通話
      navigator.mediaDevices.getUserMedia({audio:true})
      .then(stream => {
        localStream = stream;
        call = peer.call(targetId, stream);
        setupCall(call);
      })
      .catch(e => {
        log('取得麥克風失敗：' + e);
        setStatus('取得麥克風失敗');
      });
    });

    conn.on('data', onDataReceived);

    conn.on('error', e => log('連線錯誤：' + e));
    conn.on('close', () => {
      setStatus('連線已斷開');
      log('DataChannel關閉');
      conn = null;
      call = null;
    });
  };

  // 預先產生ID並初始化Peer，視為房主，等待他人連線
  isHost = true;
  const myGeneratedId = gen5DigitId();
  setupPeer(myGeneratedId);

  // --- 以下與前面相同，three.js 場景與控制 ---

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x333333);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,2,5);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  const floorGeo = new THREE.PlaneGeometry(50,50);
  const floorMat = new THREE.MeshStandardMaterial({color:0x555555});
  const floorMesh = new THREE.Mesh(floorGeo, floorMat);
  floorMesh.rotation.x = -Math.PI/2;
  floorMesh.receiveShadow = true;
  scene.add(floorMesh);

  const walls = [];

  function createWall(x,y,z,w,h,d){
    const geo = new THREE.BoxGeometry(w,h,d);
    const mat = new THREE.MeshStandardMaterial({color:0x888888});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x,y,z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);

    const box = new THREE.Box3().setFromObject(mesh);
    walls.push(box);
    return mesh;
  }

  createWall(0,2.5,-25, 50,5,1);
  createWall(0,2.5,25, 50,5,1);
  createWall(-25,2.5,0, 1,5,50);
  createWall(25,2.5,0, 1,5,50);

  const playerGeo = new THREE.BoxGeometry(0.8,1.7,0.8);

  const loader = new THREE.TextureLoader();

  const playerTextureURL = 'https://i.imgur.com/WLVaWVa.png';
  const enemyTextureURL = 'https://i.imgur.com/s8PUpct.png';

  const playerTex = loader.load(playerTextureURL);
  const enemyTex = loader.load(enemyTextureURL);

  const playerMat = new THREE.MeshStandardMaterial({map: playerTex});
  const enemyMat = new THREE.MeshStandardMaterial({map: enemyTex});

  const playerMesh = new THREE.Mesh(playerGeo, playerMat);
  scene.add(playerMesh);

  const enemyMesh = new THREE.Mesh(playerGeo, enemyMat);
  scene.add(enemyMesh);

  const player = {
    pos: new THREE.Vector3(0,0.85,0),
    vel: new THREE.Vector3(0,0,0),
    yaw: 0,
    pitch: 0,
    grounded: false,
  };

  const enemy = {
    pos: new THREE.Vector3(3,0.85,0),
    yaw: 0,
    pitch: 0,
  };

  const keys = {};
  window.addEventListener('keydown', e => { keys[e.code] = true; });
  window.addEventListener('keyup', e => { keys[e.code] = false; });

  function onMouseMove(e){
    player.yaw -= e.movementX * 0.002;
    player.pitch -= e.movementY * 0.002;
    const pitchLimit = Math.PI/2 - 0.1;
    player.pitch = Math.min(pitchLimit, Math.max(-pitchLimit, player.pitch));
  }
  document.body.addEventListener('click', ()=>document.body.requestPointerLock());
  document.addEventListener('pointerlockchange', ()=>{
    if(document.pointerLockElement === document.body){
      document.addEventListener('mousemove', onMouseMove);
    } else {
      document.removeEventListener('mousemove', onMouseMove);
    }
  });

  function getPlayerBox(pos){
    const halfWidth = 0.4;
    return new THREE.Box3(
      new THREE.Vector3(pos.x - halfWidth, pos.y - 1.7, pos.z - halfWidth),
      new THREE.Vector3(pos.x + halfWidth, pos.y, pos.z + halfWidth)
    );
  }

  function checkCollision(newPos){
    const pBox = getPlayerBox(newPos);
    for(let wallBox of walls){
      if(pBox.intersectsBox(wallBox)){
        return true;
      }
    }
    return false;
  }

  function tryMove(dx, dy, dz){
    const newPos = player.pos.clone().add(new THREE.Vector3(dx, dy, dz));
    if(!checkCollision(newPos)){
      player.pos.copy(newPos);
      playerMesh.position.copy(player.pos);
    }
  }

  const moveSpeed = 5;
  const jumpVelocity = 6;
  const gravity = -9.8;

  function tryJump(){
    if(player.grounded){
      player.vel.y = jumpVelocity;
      player.grounded = false;
    }
  }

  function onDataReceived(data){
    if(data.pos){
      enemy.pos.set(data.pos.x, data.pos.y, data.pos.z);
      enemyMesh.position.copy(enemy.pos);
    }
    if(data.yaw !== undefined) enemy.yaw = data.yaw;
    if(data.pitch !== undefined) enemy.pitch = data.pitch;
  }

  function sendPlayerState(){
    if(conn && conn.open){
      conn.send({
        pos: {x: player.pos.x, y: player.pos.y, z: player.pos.z},
        yaw: player.yaw,
        pitch: player.pitch,
      });
    }
  }

  let lastTime = performance.now();

  function animate(){
    requestAnimationFrame(animate);

    let now = performance.now();
    let delta = (now - lastTime)/1000;
    lastTime = now;

    let moveX = 0, moveZ = 0;
    if(keys['KeyW']) moveZ -= 1;
    if(keys['KeyS']) moveZ += 1;
    if(keys['KeyA']) moveX -= 1;
    if(keys['KeyD']) moveX += 1;

    let moveDir = new THREE.Vector3();
    if(moveX !== 0 || moveZ !== 0){
      moveDir.set(moveX, 0, moveZ).normalize();

      const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
      const right = new THREE.Vector3(Math.sin(player.yaw + Math.PI/2), 0, Math.cos(player.yaw + Math.PI/2));

      const worldMove = new THREE.Vector3();
      worldMove.addScaledVector(forward, moveDir.z);
      worldMove.addScaledVector(right, moveDir.x);
      worldMove.multiplyScalar(moveSpeed * delta);

      tryMove(worldMove.x, 0, worldMove.z);
    }

    if(keys['Space']){
      tryJump();
    }

    player.vel.y += gravity * delta;
    const newY = player.pos.y + player.vel.y * delta;

    if(newY < 0.85){
      player.vel.y = 0;
      player.pos.y = 0.85;
      player.grounded = true;
    } else {
      const testPos = player.pos.clone();
      testPos.y = newY;
      if(!checkCollision(testPos)){
        player.pos.y = newY;
      } else {
        player.vel.y = 0;
      }
      player.grounded = false;
    }

    playerMesh.position.copy(player.pos);

    camera.position.copy(player.pos).add(new THREE.Vector3(0,0.6,0));
    camera.rotation.order = 'YXZ';
    camera.rotation.y = player.yaw;
    camera.rotation.x = player.pitch;

    if(now - (sendPlayerState.lastSend||0) > 33){
      sendPlayerState();
      sendPlayerState.lastSend = now;
    }

    renderer.render(scene, camera);
  }

  animate();

  // 啟用麥克風在點擊時
  document.body.addEventListener('click', () => {
    if(localStream) return;
    navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
      localStream = stream;
      log('麥克風已啟用');
    }).catch(e=>{
      log('麥克風啟用失敗：' + e);
    });
  });
</script>
</body>
</html>
