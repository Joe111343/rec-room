<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>P2P 踩頭掉落遊戲</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 6px; }
  #ui input { width: 80px; }
</style>
</head>
<body>
<div id="ui">
  房間ID：<input id="room" maxlength="5" placeholder="12345">
  <button id="connect">連線</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>
<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 環境光與方向光
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
let dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, 5);
scene.add(dirLight);

// 地板
let floorTex = new THREE.TextureLoader().load("https://threejs.org/examples/textures/grasslight-big.jpg");
floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
floorTex.repeat.set(20, 20);
let floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({map: floorTex}));
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// 玩家
let player = {
  pos: new THREE.Vector3(0, 2, 0),
  vel: new THREE.Vector3(),
  isOnGround: false
};

// 另一位玩家
let remoteMesh = null;
let enemy = { interp: new THREE.Vector3() };

// 控制
let keys = {};
document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);

// 滑鼠鎖定
renderer.domElement.addEventListener('click', ()=> {
  renderer.domElement.requestPointerLock();
});
let yaw = 0, pitch = 0;
document.addEventListener('mousemove', e => {
  if (document.pointerLockElement === renderer.domElement) {
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
  }
});

// 碰撞用 Box
function playerBoxAt(pos) {
  let box = new THREE.Box3();
  box.setFromCenterAndSize(new THREE.Vector3(pos.x, pos.y+1, pos.z), new THREE.Vector3(0.6, 2, 0.6));
  return box;
}

// 空中可移動 + 踩頭掉落邏輯
function collides(testPos) {
  if (!player.isOnGround) {
    // 空中：檢查踩頭
    if (remoteMesh) {
      let enemyBox = playerBoxAt(enemy.interp);
      let pb = playerBoxAt(testPos);
      let isAbove = player.pos.y > enemy.interp.y + 1.5;
      if (isAbove && pb.intersectsBox(enemyBox)) {
        player.vel.y = -Math.abs(player.vel.y || 5); // 踩到頭 → 往下掉
      }
    }
    return false; // 空中不阻擋
  }
  // 地面：檢查對方阻擋
  if (remoteMesh) {
    let enemyBox = playerBoxAt(enemy.interp);
    if (playerBoxAt(testPos).intersectsBox(enemyBox)) return true;
  }
  return false;
}

// 簡單房間牆
let wallGeo = new THREE.BoxGeometry(1, 5, 10);
let wallMat = new THREE.MeshStandardMaterial({color: 0x888888});
let wall = new THREE.Mesh(wallGeo, wallMat);
wall.position.set(5, 2.5, 0);
scene.add(wall);
let walls = [new THREE.Box3().setFromObject(wall)];

// 房間連線
let peer, isHost = false;
let btn = document.getElementById("connect");
let input = document.getElementById("room");
btn.onclick = ()=>{
  input.blur();
  document.getElementById("ui").style.display = "none";
  isHost = true; // 簡化：第一個開按鈕的當房主
  startPeer();
};
function startPeer(){
  peer = new SimplePeer({initiator: isHost, trickle: false});
  peer.on('signal', data => {
    console.log("Signal data:", JSON.stringify(data));
  });
  peer.on('connect', ()=> {
    console.log("Connected!");
  });
  peer.on('data', d => {
    let msg = JSON.parse(d);
    if (msg.type === 'pos') enemy.interp.set(msg.x, msg.y, msg.z);
  });
}
function sendPos(){
  if (peer && peer.connected) {
    peer.send(JSON.stringify({type:'pos', x:player.pos.x, y:player.pos.y, z:player.pos.z}));
  }
}

// 遊戲主循環
let clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  let delta = clock.getDelta();

  // 移動
  let dir = new THREE.Vector3();
  if (keys['KeyW']) dir.z -= 1;
  if (keys['KeyS']) dir.z += 1;
  if (keys['KeyA']) dir.x -= 1;
  if (keys['KeyD']) dir.x += 1;
  if (dir.length() > 0) {
    dir.normalize();
    let forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    let right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();
    let moveVec = new THREE.Vector3();
    moveVec.addScaledVector(forward, -dir.z);
    moveVec.addScaledVector(right, dir.x);
    moveVec.multiplyScalar(5 * delta);
    let testPos = player.pos.clone().add(moveVec);
    if (!collides(testPos)) player.pos.copy(testPos);
  }

  // 重力
  player.vel.y -= 9.8 * delta;
  player.pos.y += player.vel.y * delta;

  // 簡單地面檢測
  if (player.pos.y < 1) {
    player.pos.y = 1;
    player.vel.y = 0;
    player.isOnGround = true;
  } else {
    player.isOnGround = false;
  }

  // 相機位置與朝向
  camera.position.copy(player.pos).add(new THREE.Vector3(0, 1.6, 0));
  camera.rotation.set(pitch, yaw, 0);

  // 更新對方模型
  if (enemy.interp && !remoteMesh) {
    let geo = new THREE.CapsuleGeometry(0.3, 1.2, 4, 8);
    let mat = new THREE.MeshStandardMaterial({color:0xff0000});
    remoteMesh = new THREE.Mesh(geo, mat);
    scene.add(remoteMesh);
  }
  if (remoteMesh) remoteMesh.position.copy(enemy.interp);

  // 傳位置
  sendPos();

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
