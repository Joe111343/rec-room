<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>P2P多人語音＋位置同步＋碰撞完整示範</title>
<style>
  body { margin:0; overflow:hidden; background:#222; color:#eee; font-family: monospace; }
  #ui {
    position: fixed; top: 10px; left: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px; border-radius: 5px; max-width: 300px;
    z-index: 10;
  }
  #log {
    max-height: 100px; overflow-y: auto; margin-top: 10px; font-size: 12px;
    background: #111; padding: 5px; border-radius: 3px;
  }
</style>
</head>
<body>

<div id="ui">
  <div>你的ID：<span id="myId">...</span></div>
  <div>
    連線對方ID：<input id="peerIdInput" style="width:140px" />
    <button id="connectBtn">連線</button>
  </div>
  <div id="status">尚未連線</div>
  <div id="log"></div>
  <div style="margin-top:8px; font-size:14px;">
    WASD移動，滑鼠看視角，空白跳<br>
    點擊畫面啟用滑鼠控制<br>
    連線後說話可聽見彼此聲音
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

<script>
  // DOM元素
  const logElem = document.getElementById('log');
  function log(text){
    logElem.textContent += text + '\n';
    logElem.scrollTop = logElem.scrollHeight;
  }
  const myIdSpan = document.getElementById('myId');
  const statusDiv = document.getElementById('status');
  const connectBtn = document.getElementById('connectBtn');
  const peerIdInput = document.getElementById('peerIdInput');

  // 初始化PeerJS
  const peer = new Peer({
    debug: 2
  });

  let conn = null;
  let call = null;
  let localStream = null;

  peer.on('open', id => {
    myIdSpan.textContent = id;
    log('Peer ID: ' + id);
  });

  peer.on('error', err => {
    log('Error: ' + err);
  });

  // 接收DataChannel連線
  peer.on('connection', connection => {
    if(conn) {
      connection.close(); // 只接受一個連線
      log('已有連線，拒絕新連線');
      return;
    }
    conn = connection;
    setupDataConn();
  });

  // 接收語音通話
  peer.on('call', incomingCall => {
    navigator.mediaDevices.getUserMedia({audio:true})
    .then(stream => {
      localStream = stream;
      incomingCall.answer(stream);
      setupCall(incomingCall);
    })
    .catch(e => log('取得麥克風失敗：' + e));
  });

  connectBtn.onclick = () => {
    if(conn) {
      log('已連線，請重新整理頁面以連線新對象');
      return;
    }
    const peerId = peerIdInput.value.trim();
    if(!peerId) return alert('請輸入對方ID');
    log('嘗試連線: ' + peerId);
    conn = peer.connect(peerId);
    setupDataConn();

    // 拿麥克風
    navigator.mediaDevices.getUserMedia({audio:true})
    .then(stream => {
      localStream = stream;
      call = peer.call(peerId, stream);
      setupCall(call);
    })
    .catch(e => log('取得麥克風失敗：' + e));
  };

  function setupDataConn(){
    statusDiv.textContent = '已連線 (DataChannel)';
    log('DataChannel連線建立');
    conn.on('data', onDataReceived);
    conn.on('close', () => {
      log('DataChannel關閉');
      statusDiv.textContent = '連線已斷開';
      conn = null;
      call = null;
    });
    conn.on('error', e => log('DataChannel錯誤：' + e));
  }

  function setupCall(c){
    statusDiv.textContent = '已連線 (語音通話)';
    call = c;
    call.on('stream', remoteStream => {
      const audio = new Audio();
      audio.srcObject = remoteStream;
      audio.play();
      log('開始播放遠端語音');
    });
    call.on('close', () => {
      log('語音通話結束');
      statusDiv.textContent = '連線已斷開';
      call = null;
    });
  }

  // three.js 初始化場景
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x333333);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,2,5);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // 燈光
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // 地板
  const floorGeo = new THREE.PlaneGeometry(50,50);
  const floorMat = new THREE.MeshStandardMaterial({color:0x555555});
  const floorMesh = new THREE.Mesh(floorGeo, floorMat);
  floorMesh.rotation.x = -Math.PI/2;
  floorMesh.receiveShadow = true;
  scene.add(floorMesh);

  // 牆壁與碰撞盒陣列
  const walls = [];

  function createWall(x,y,z,w,h,d){
    const geo = new THREE.BoxGeometry(w,h,d);
    const mat = new THREE.MeshStandardMaterial({color:0x888888});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x,y,z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);

    // 建立碰撞盒
    const box = new THREE.Box3().setFromObject(mesh);
    walls.push(box);
    return mesh;
  }

  // 牆壁擺放
  createWall(0,2.5,-25, 50,5,1);
  createWall(0,2.5,25, 50,5,1);
  createWall(-25,2.5,0, 1,5,50);
  createWall(25,2.5,0, 1,5,50);

  // 玩家模型（綠色方塊）
  const playerGeo = new THREE.BoxGeometry(0.8,1.7,0.8);
  const playerMat = new THREE.MeshStandardMaterial({color:0x00ff00});
  const playerMesh = new THREE.Mesh(playerGeo, playerMat);
  scene.add(playerMesh);

  // 對手模型（紅色方塊）
  const enemyMat = new THREE.MeshStandardMaterial({color:0xff0000});
  const enemyMesh = new THREE.Mesh(playerGeo, enemyMat);
  scene.add(enemyMesh);

  // 玩家資料
  const player = {
    pos: new THREE.Vector3(0,0.85,0),
    vel: new THREE.Vector3(0,0,0),
    yaw: 0,
    pitch: 0,
    grounded: false,
  };

  const enemy = {
    pos: new THREE.Vector3(3,0.85,0),
    yaw: 0,
    pitch: 0,
  };

  // 鍵盤控制
  const keys = {};
  window.addEventListener('keydown', e => { keys[e.code] = true; });
  window.addEventListener('keyup', e => { keys[e.code] = false; });

  // 滑鼠視角
  function onMouseMove(e){
    player.yaw -= e.movementX * 0.002;
    player.pitch -= e.movementY * 0.002;
    const pitchLimit = Math.PI/2 - 0.1;
    player.pitch = Math.min(pitchLimit, Math.max(-pitchLimit, player.pitch));
  }
  document.body.addEventListener('click', ()=>document.body.requestPointerLock());
  document.addEventListener('pointerlockchange', ()=>{
    if(document.pointerLockElement === document.body){
      document.addEventListener('mousemove', onMouseMove);
    } else {
      document.removeEventListener('mousemove', onMouseMove);
    }
  });

  // 玩家碰撞盒 (AABB)
  function getPlayerBox(pos){
    const halfWidth = 0.4;
    return new THREE.Box3(
      new THREE.Vector3(pos.x - halfWidth, pos.y - 1.7, pos.z - halfWidth),
      new THREE.Vector3(pos.x + halfWidth, pos.y, pos.z + halfWidth)
    );
  }

  // 碰撞偵測，回傳是否撞牆
  function checkCollision(newPos){
    const pBox = getPlayerBox(newPos);
    for(let wallBox of walls){
      if(pBox.intersectsBox(wallBox)){
        return true;
      }
    }
    return false;
  }

  // 玩家嘗試移動
  function tryMove(dx, dy, dz){
    const newPos = player.pos.clone().add(new THREE.Vector3(dx, dy, dz));
    if(!checkCollision(newPos)){
      player.pos.copy(newPos);
      playerMesh.position.copy(player.pos);
    }
  }

  // 移動速度與跳躍
  const moveSpeed = 5;
  const jumpVelocity = 6;
  const gravity = -9.8;

  function tryJump(){
    if(player.grounded){
      player.vel.y = jumpVelocity;
      player.grounded = false;
    }
  }

  // 接收對方資料，更新對手位置與視角
  function onDataReceived(data){
    if(data.pos){
      enemy.pos.set(data.pos.x, data.pos.y, data.pos.z);
      enemyMesh.position.copy(enemy.pos);
    }
    if(data.yaw !== undefined) enemy.yaw = data.yaw;
    if(data.pitch !== undefined) enemy.pitch = data.pitch;
    // 可擴充：接收對方動作、物品等
  }

  // 傳送玩家狀態給對方
  function sendPlayerState(){
    if(conn && conn.open){
      conn.send({
        pos: {x: player.pos.x, y: player.pos.y, z: player.pos.z},
        yaw: player.yaw,
        pitch: player.pitch,
      });
    }
  }

  let lastTime = performance.now();

  // 主迴圈
  function animate(){
    requestAnimationFrame(animate);

    let now = performance.now();
    let delta = (now - lastTime)/1000;
    lastTime = now;

    // 玩家移動計算
    let moveX = 0, moveZ = 0;
    if(keys['KeyW']) moveZ -= 1;
    if(keys['KeyS']) moveZ += 1;
    if(keys['KeyA']) moveX -= 1;
    if(keys['KeyD']) moveX += 1;

    let moveDir = new THREE.Vector3();
    if(moveX !== 0 || moveZ !== 0){
      moveDir.set(moveX, 0, moveZ).normalize();
      // 轉換成世界座標方向
      const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
      const right = new THREE.Vector3(Math.sin(player.yaw + Math.PI/2), 0, Math.cos(player.yaw + Math.PI/2));

      const worldMove = new THREE.Vector3();
      worldMove.addScaledVector(forward, moveDir.z);
      worldMove.addScaledVector(right, moveDir.x);
      worldMove.multiplyScalar(moveSpeed * delta);

      tryMove(worldMove.x, 0, worldMove.z);
    }

    // 跳躍
    if(keys['Space']){
      tryJump();
    }

    // 重力
    player.vel.y += gravity * delta;
    const newY = player.pos.y + player.vel.y * delta;

    // 地面高度 0.85 (玩家腳底+0.85=0，玩家高度1.7)
    if(newY < 0.85){
      player.vel.y = 0;
      player.pos.y = 0.85;
      player.grounded = true;
    } else {
      // 先試移動y軸方向碰撞（跳躍碰天花板可加）
      const testPos = player.pos.clone();
      testPos.y = newY;
      if(!checkCollision(testPos)){
        player.pos.y = newY;
      } else {
        player.vel.y = 0; // 碰撞頂天花板
      }
      playerMesh.position.y = player.pos.y;
    }

    // 更新相機位置及視角（第一人稱）
    const camHeight = 1.6;
    camera.position.set(player.pos.x, player.pos.y + camHeight - 0.85, player.pos.z);
    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');

    // 傳送玩家狀態
    sendPlayerState();

    // 對手方塊更新位置（插值平滑可加）
    enemyMesh.position.copy(enemy.pos);

    renderer.render(scene, camera);
  }

  animate();

  // 視窗大小調整
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>

</body>
</html>
